#!/usr/bin/perl
   eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
       if $running_under_some_shell;

# If debugging is the process of removing bugs, then programming must be the
# process of putting them in.
#   - Edsger Dijkstra

use strict;
use warnings;

use vars qw($VERSION);

$VERSION = '0.06';

=head1 NAME

tagr - flexibly tag file

=head1 SYNOPSIS

=head1 DESCRIPTION

=head2 Options

=over 3

=item B<< -a <tags> >>, B<< --add <tags> >>

Add a tag

=item B<-c>, B<--create-db>

Create a tags database in $HOME/.tagr

=item B<-v>, B<--version>

Display version number and exit

=item B<-h>, B<-?>, B<--help>

show a usage message

=back

=head1 BUGS

None known

=head1 LIMITATIONS

=head1 TO DO

=head1 AUTHOR

Kim Rutherford <kmr+tagr@xenu.org.uk>

http://www.xenu.org.uk

=cut

use File::Tagr;
use File::Tagr::DB;
use File::Tagr::Magic;

use Term::ReadLine;
use Tree::Trie;

use Getopt::Long;
use Pod::Usage;
use Cwd qw(abs_path);
use File::Basename;

my $cdir = "$ENV{HOME}/.tagr";
my $option_parser = new Getopt::Long::Parser;
$option_parser->configure("gnu_getopt");

# set defaults
my %options = (
               auto_tag => undef,
               tag => undef,
               find => undef,
               shell => undef,
               create_db => undef,
               update => undef,
               recurse => undef,
              );

my $need_help = 0;
my $need_version = 0;
my $verbose = 0;

my %opt_config = (
                  "auto-tag|a" => \$options{auto_tag},
                  "tag|t=s" => \$options{tag},
                  "find|f=s" => \$options{find},
                  "create-db|c" => \$options{create_db},
                  "update|u" => \$options{update},
                  "shell|s" => \$options{shell},
                  "recurse|R" => \$options{recurse},
                  "version|V" => \$need_version,
                  "verbose|v" => \$verbose,
                  "help|h|?" => \$need_help,
                 );

my @IGNORE_PATTERNS = qw(~$ ~\.gz$ ^\..*$ ^CVS$ \.log(\.\d+)?$);
my $IGNORE_PATTERN = join '|', @IGNORE_PATTERNS;

my $HISTFILE = "$ENV{HOME}/.tagr_history";
my $HISTSIZE = 5000;

if (!$option_parser->getoptions(%opt_config)) {
  usage(2);
}

if ($need_help) {
  usage(1);
}

if ($need_version) {
  print "tagr version $VERSION\n";
  exit(0);
}

sub usage
{
  my $exit_val = shift;
  my $message = shift;
  if (defined $message) {
    pod2usage(-verbose => 1, -exitval => $exit_val, -message => $message);
  } else {
    pod2usage(-verbose => 1, -exitval => $exit_val);
  }
}

my $tagr = new File::Tagr(config_dir => $cdir, verbose => $verbose);

sub exit_and_commit
{
  my $exit_code = shift;
  $tagr->db()->txn_commit();
  exit($exit_code);
}

if ($options{create_db}) {
  if (@ARGV) {
    usage(2, "error: no arguments needed\n");
  }

  $tagr->create_db();
  exit_and_commit(0);
}

sub tag_file
{
  my $filepath = shift;
  my $tag = shift;

  my @tags = split /,/, $tag;
  if ($verbose) {
    warn qq[tagging "$filepath" with: @tags\n];
  }
  $tagr->tag_file($filepath, @tags);
}

if ($options{tag}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if (defined $file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       tag_file($filepath, (split /,/, $options{tag}));
                     });
      } else {
        tag_file($file_fullpath, (split /,/, $options{tag}));
      }
    }
  }
  exit_and_commit(0);
}

sub _dir_recurse
{
  my $file = shift;
  my $cb = shift;
  my @args = @_;

  my $file_fullpath = _test_and_canon($file);

  if (!defined $file_fullpath) {
    return;
  }

  my $file_lastpart = fileparse($file_fullpath);

  if ($file_lastpart =~ /$IGNORE_PATTERN/) {
    if ($verbose) {
      warn "ignored: $file_fullpath\n";
    }
    return;
  }

  if (-f $file_fullpath) {
    &${cb}($file_fullpath, @args);
  } else {
    if (-d $file_fullpath) {
      if ($verbose) {
        warn "recursing: $file_fullpath\n";
      }
      opendir my $dh, "$file_fullpath" or die "can't open directory: $file_fullpath - $!\n";
      while (defined(my $dir_ent = readdir($dh))) {
        if ($dir_ent ne '..' and $dir_ent ne '.') {
          _dir_recurse("$file_fullpath/$dir_ent", $cb, @args);
        }
      }
      closedir $dh;
    }
  }
}

sub update_file
{
  my $filepath = shift;
  if ($verbose) {
    warn qq[updating "$filepath"\n];
  }
  $tagr->update_file($filepath, @_);
}

if (defined $options{update}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if ($file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       update_file($filepath, @_);
                     });
      } else {
        $tagr->update_file($file_fullpath);
      }
    }
  }
  $tagr->db()->txn_commit();
  exit_and_commit(0);
}

if (defined $options{find}) {
  if (@ARGV) {
    usage(2, "error: too many arguments\n");
  }

  $tagr->find_file_by_tag($options{find});
  exit_and_commit(0);
}

sub shell_tag
{
  my $filename = shift;
  my $term = shift;
  my $trie = shift;

  if (!defined $trie) {
    die "\$trie not defined\n";
  }

  $tagr->update_file($filename);

  my $prompt = "tags for $filename: ";
  my $OUT = $term->OUT || \*STDOUT;

  my @tag_names = map {$_->detail} $tagr->get_tags_of_file($filename);

  warn "current tags: @tag_names\n";

  if (grep {$_ eq 'image'} @tag_names) {
    my $new_pid;
    if (!defined($new_pid = fork())) {
      # fork returned undef, so failed
      die "cannot fork: $!";
    } elsif ($new_pid == 0) {
      # fork returned 0, so this branch is the child
      my $command = 'xv';
      exec($command, '-root', '-rmode', '5', '-quit', $filename);
      # if the exec fails, fall through to the next statement
      die "can't exec $command: $!";
    }

  }

  my $line = $term->readline($prompt);

  if (defined $line) {
    if (length $line > 0) {
      if ($line eq 'exit' or $line eq 'quit' or $line eq 'q') {
        exit_and_commit(0);
      }

      $term->WriteHistory($HISTFILE);

      warn $@ if $@;
      my @words = split / /, $line;
      for my $word (@words) {
        if (!$trie->lookup($word, 'exact')) {
          $trie->add($word);
        }
        tag_file($filename, $word);
        $tagr->db->txn_commit();
      }
      $term->addhistory($line) if $line =~ /\S/;
    }
  } else {
    warn "\n";
    system("xsetroot -solid black &");
    exit_and_commit(0);
  }

  $tagr->db()->txn_commit();
}

if ($options{shell}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  my $term = new Term::ReadLine 'Tagr shell';
  my $attribs = $term->Attribs;

  $term->stifle_history($HISTSIZE);
  if (-f $HISTFILE) {
    $term->ReadHistory($HISTFILE)
    or warn "perlsh: cannot read history file: $!\n";
  }

  my $trie = new Tree::Trie;

  my @tag_names = $tagr->get_tag_names();

  $trie->add(@tag_names);

  $attribs->{completion_function} = sub {
    my ($text, $line, $start) = @_;
    return $trie->lookup($text);
  };

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if ($file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       shell_tag($filepath, @_);
                     }, $term, $trie);
      } else {
        shell_tag($file_fullpath, $term, $trie);
      }
    }
  }
  $tagr->db()->txn_commit();
  exit_and_commit(0);
}

sub _test_and_canon
{
  my $file = shift;
  if (-l $file) {
    if ($verbose) {
      warn "ignoring symbolic link: $file\n";
    }
    return undef;
  }

  if (!-r $file) {
    if ($verbose) {
      warn "ignoring unreadable file: $file\n";
    }
    return undef;
  }

  my $file_fullpath = abs_path($file);

  return $file_fullpath;
}

# if ($options{auto_tag}) {
#   if (@ARGV < 1) {
#     usage(2, "error: one or more files arguments needed\n");
#   }

#   for my $file (@ARGV) {
#     if (-e $file) {
#       _auto_tag_file($file);
#     } else {
#       warn "$0: warning: $file doesn't exists\n";
#     }
#   }
#   exit(0);
# }


