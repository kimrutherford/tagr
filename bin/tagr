#!/usr/bin/perl
   eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
       if $running_under_some_shell;

# If debugging is the process of removing bugs, then programming must be the
# process of putting them in.
#   - Edsger Dijkstra

use strict;
use warnings;

use vars qw($VERSION);

$VERSION = '0.06';

=head1 NAME

tagr - flexibly tag file

=head1 SYNOPSIS

=head1 DESCRIPTION

=head2 Options

=over 3

=item B<< -a <tags> >>, B<< --add <tags> >>

Add a tag

=item B<-c>, B<--create-db>

Create a tags database in $HOME/.tagr

=item B<-v>, B<--version>

Display version number and exit

=item B<-h>, B<-?>, B<--help>

show a usage message

=back

=head1 BUGS

None known

=head1 LIMITATIONS

=head1 TO DO

=head1 AUTHOR

Kim Rutherford <kmr+tagr@xenu.org.uk>

http://www.xenu.org.uk

=cut

use File::Tagr;
use File::Tagr::DB;
use File::Tagr::Magic;

use Getopt::Long;
use Pod::Usage;
use Cwd qw(abs_path);
use File::Basename;

my $cdir = "$ENV{HOME}/.tagr";
my $option_parser = new Getopt::Long::Parser;
$option_parser->configure("gnu_getopt");

# set defaults
my %options = (
               auto_tag => 0,
               tag => 0,
               find => 0,
               create_db => 0
              );

my $need_help = 0;
my $need_version = 0;

my %opt_config = (
                  "auto-tag|a" => \$options{auto_tag},
                  "tag|t=s" => \$options{tag},
                  "find|f=s" => \$options{find},
                  "create-db|c" => \$options{create_db},
                  "version|v" => \$need_version,
                  "help|h|?" => \$need_help,
                 );

my @IGNORE_PATTERNS = qw(~$ ^\..*$ ^CVS$ \.log(\.\d+)?$);
my $IGNORE_PATTERN = join '|', @IGNORE_PATTERNS;

if (!$option_parser->getoptions(%opt_config)) {
  usage(2);
}

if ($need_help) {
  usage(1);
}

if ($need_version) {
  print "tagr version $VERSION\n";
  exit(0);
}

sub usage
{
  my $exit_val = shift;
  my $message = shift;
  if (defined $message) {
    pod2usage(-verbose => 1, -exitval => $exit_val, -message => $message);
  } else {
    pod2usage(-verbose => 1, -exitval => $exit_val);
  }
}

my $tagr = new File::Tagr(config_dir => $cdir);

if ($options{create_db}) {
  if (@ARGV) {
    usage(2, "error: no arguments needed\n");
  }

  $tagr->create_db();
  exit (0);
}


if ($options{tag}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    $tagr->tag_file($file, split /,/, $options{tag});
  }
  exit(0);
}

if ($options{find}) {
  if (@ARGV) {
    usage(2, "error: too many arguments\n");
  }

  $tagr->find_file_by_tag($options{find});
  exit(0);
}

sub _auto_tag_file
{
  my $file = shift;

  if (-l $file) {
    warn "ignoring symbolic link: $file\n";
    return;
  }

  my $file_fullpath = abs_path($file);
  my $file_lastpart = fileparse($file_fullpath);

  if ($file_lastpart =~ /$IGNORE_PATTERN/) {
    warn "ignored: $file_fullpath\n";
    return;
  }

  if (-f $file_fullpath) {
    warn "tagging: $file_fullpath\n";
    $tagr->auto_tag($file_fullpath);
  } else {
    if (-d $file_fullpath) {
      warn "recursing: $file_fullpath\n";
      opendir my $dh, "$file_fullpath" or die "can't open directory: $file_fullpath - $!\n";
      while (defined(my $dir_ent = readdir($dh))) {
        if ($dir_ent ne '..' and $dir_ent ne '.') {
          _auto_tag_file("$file_fullpath/$dir_ent");
        }
      }
      closedir $dh;
    }
  }
}

if ($options{auto_tag}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    if (-e $file) {
      _auto_tag_file($file);
    } else {
      warn "$0: warning: $file doesn't exists\n";
    }
  }
  exit(0);
}


