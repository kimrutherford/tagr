#!/usr/bin/perl
   eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
       if $running_under_some_shell;

# If debugging is the process of removing bugs, then programming must be the
# process of putting them in.
#   - Edsger Dijkstra

use strict;
use warnings;

use vars qw($VERSION);

$VERSION = '0.06';

=head1 NAME

tagr - flexibly tag file

=head1 SYNOPSIS

=head1 DESCRIPTION

=head2 Options

=over 3

=item B<< -a <tags> >>, B<< --add <tags> >>

Add a tag

=item B<-c>, B<--create-db>

Create a tags database in $HOME/.tagr

=item B<-v>, B<--version>

Display version number and exit

=item B<-h>, B<-?>, B<--help>

show a usage message

=back

=head1 BUGS

None known

=head1 LIMITATIONS

=head1 TO DO

=head1 AUTHOR

Kim Rutherford <kmr+tagr@xenu.org.uk>

http://www.xenu.org.uk

=cut

use File::Tagr;
use File::Tagr::DB;
use File::Tagr::Magic;
use File::Tagr::Description;

use Term::ReadLine;
use Tree::Trie;

use Getopt::Long;
use Pod::Usage;
use Cwd qw(abs_path);
use File::Basename;

my $cdir = "$ENV{HOME}/.tagr";
my $option_parser = new Getopt::Long::Parser;
$option_parser->configure("gnu_getopt");

# set defaults
my %options = (
               auto_tag => undef,
               tag => undef,
               describe => undef,
               find => undef,
               create_db => undef,
               update => undef,
               mix => undef,
               shell => undef,
               get_tags => undef,
               get_description => undef,
               execute => undef,
               recurse => undef,
              );

my $need_help = 0;
my $need_version = 0;
my $verbose = 0;

my %opt_config = (
                  "auto-tag|a" => \$options{auto_tag},
                  "tag|t=s" => \$options{tag},
                  "describe|d=s" => \$options{describe},
                  "find|f" => \$options{find},
                  "create-db|c" => \$options{create_db},
                  "update|u" => \$options{update},
                  "mix|m" => \$options{mix},
                  "shell|s" => \$options{shell},
                  "get-tags|T" => \$options{get_tags},
                  "get-description|D" => \$options{get_description},
                  "execute|e=s" => \$options{execute},
                  "recurse|R" => \$options{recurse},
                  "version|V" => \$need_version,
                  "verbose|v" => \$verbose,
                  "help|h|?" => \$need_help,
                 );

my @IGNORE_PATTERNS = qw(~$ ~\.gz$ ^\..*$ ^CVS$ \.log(\.\d+)?$);
my $IGNORE_PATTERN = join '|', @IGNORE_PATTERNS;

my $HISTFILE = "$ENV{HOME}/.tagr_history";
my $HISTSIZE = 5000;

if (!$option_parser->getoptions(%opt_config)) {
  usage(2);
}

if ($need_help) {
  usage(1);
}

if ($need_version) {
  print "tagr version $VERSION\n";
  exit(0);
}

sub usage
{
  my $exit_val = shift;
  my $message = shift;
  if (defined $message) {
    pod2usage(-verbose => 1, -exitval => $exit_val, -message => $message);
  } else {
    pod2usage(-verbose => 1, -exitval => $exit_val);
  }
}

my $tagr = new File::Tagr(config_dir => $cdir, verbose => $verbose);

sub exit_and_commit
{
  my $exit_code = shift;
  $tagr->db()->txn_commit();
  exit($exit_code);
}

if ($options{create_db}) {
  if (@ARGV) {
    usage(2, "error: no arguments needed\n");
  }

  $tagr->create_db();
  exit_and_commit(0);
}

sub tag_file
{
  my $filepath = shift;
  my $auto = shift;
  my @tags = shift;

  if ($verbose) {
    warn qq[tagging "$filepath" with: @tags\n];
  }
  for my $tag (@tags) {
    $tagr->tag_file($filepath, $auto, $tag);
  }
}

if ($options{tag}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if (defined $file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       tag_file($filepath, 0, (split /,/, $options{tag}));
                     });
      } else {
        tag_file($file_fullpath, 0, (split /,/, $options{tag}));
      }
    }
  }
  exit_and_commit(0);
}

sub describe_file
{
  my $filename = shift;
  my $description = shift;

  my @tags = File::Tagr::Description->get_tags_from_string($description);
  $tagr->describe_file($filename, $description);

  for my $tag (@tags) {
    $tag = lc $tag;
    tag_file($filename, 1, $tag);
  }
}

if ($options{describe}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if (defined $file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       describe_file($filepath, $options{describe});
                     });
      } else {
        describe_file($file_fullpath, $options{describe});
      }
    }
  }
  exit_and_commit(0);
}


sub _dir_recurse
{
  my $file = shift;
  my $cb = shift;
  my @args = @_;

  my $file_fullpath = _test_and_canon($file);

  if (!defined $file_fullpath) {
    return;
  }

  my $file_lastpart = fileparse($file_fullpath);

  if ($file_lastpart =~ /$IGNORE_PATTERN/) {
    if ($verbose) {
      warn "ignored: $file_fullpath\n";
    }
    return;
  }

  if (-f $file_fullpath) {
    &${cb}($file_fullpath, @args);
  } else {
    if (-d $file_fullpath) {
      if ($verbose) {
        warn "recursing: $file_fullpath\n";
      }
      opendir my $dh, "$file_fullpath" or die "can't open directory: $file_fullpath - $!\n";
      while (defined(my $dir_ent = readdir($dh))) {
        if ($dir_ent ne '..' and $dir_ent ne '.') {
          _dir_recurse("$file_fullpath/$dir_ent", $cb, @args);
        }
      }
      closedir $dh;
    }
  }
}

sub update_file
{
  my $filepath = shift;
  if ($verbose) {
    warn qq[updating "$filepath"\n];
  }
  $tagr->update_file($filepath, @_);
}

if (defined $options{update}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if ($file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       update_file($filepath, @_);
                     });
      } else {
        $tagr->update_file($file_fullpath);
      }
    }
  }
  $tagr->db()->txn_commit();
  exit_and_commit(0);
}

if (defined $options{find}) {
  if (!@ARGV) {
    usage(2, "error: enough arguments\n");
  }

  my @filenames = ();
  for my $filename ($tagr->find_file_by_tag(@ARGV)) {
    if (!defined $options{execute}) {
      print $filename, "\n";
    }
    push @filenames, $filename;
  }

  if (defined $options{execute} && @filenames) {
    system($options{execute}, @filenames);
  }

  if ($verbose && @filenames == 0) {
    warn "no matches found\n";
  }

  exit_and_commit(0);
}

sub shell_tag
{
  my $filename = shift;
  my $term = shift;
  my $trie = shift;

  if (!defined $trie) {
    die "\$trie not defined\n";
  }

  my $file = $tagr->update_file($filename);

  my $OUT = $term->OUT || \*STDOUT;

  my @tag_names = map {$_->detail} $file->hash_id()->tags();

  my $current_description = $file->hash_id()->description_id();

  if (defined $current_description) {
    warn "current description: ", $current_description->detail(), "\n";
    $term->addhistory($current_description->detail()

);
  } else {
    warn "no current description\n";
  }
  warn "current tags: @tag_names\n";

  if (grep {$_ eq 'image'} @tag_names) {
    my $new_pid;
    if (!defined($new_pid = fork())) {
      # fork returned undef, so failed
      die "cannot fork: $!";
    } elsif ($new_pid == 0) {
      my $temp_file = "/tmp/tagr_temp_$$.ppm";
      my $command =
        "convert -thumbnail 600x400 $filename $temp_file; xloadimage -border black -center -onroot -quiet $temp_file";
      # fork returned 0, so this branch is the child
      exec($command);
      # if the exec fails, fall through to the next statement
      die "can't exec $command: $!";
    }
  }

  my $line = $term->readline("description for $filename: ");

  if (defined $line) {
    if (length $line > 0) {
      if (grep {$_ eq $line} qw[q quit exit quit]) {
        exit_and_commit(0);
      }

      $term->append_history($HISTFILE);

      if ($line =~ s/\s*;;\s*(.*?)\s*$//) {
        my $tagstring = $1;

        my @words = split / /, $tagstring;
        for my $word (@words) {
          if (!$trie->lookup($word, Tree::Trie::EXACT)) {
            $trie->add($word);
          }
          tag_file($filename, 0, $word);
          $tagr->db->txn_commit();
        }
      }


      warn $@ if $@;

      my @tags = File::Tagr::Description->get_tags_from_string($line);
      $tagr->describe_file($filename, $line);

      for my $tag (@tags) {
        $tag = lc $tag;
        if (!$trie->lookup($tag, Tree::Trie::EXACT)) {
          $trie->add($tag);
        }
        tag_file($filename, 1, $tag);
        $tagr->db->txn_commit();
      }
    }
  } else {
    warn "\n";
    system("xsetroot -solid black &");
    exit_and_commit(0);
  }

  $tagr->db()->txn_commit();
}

if ($options{shell}) {
  if (@ARGV < 1) {
    usage(2, "error: one or more files arguments needed\n");
  }

  my $term = new Term::ReadLine 'Tagr shell';
  my $attribs = $term->Attribs;

  $term->stifle_history($HISTSIZE);
  if (-f $HISTFILE) {
    $term->ReadHistory($HISTFILE)
    or warn "perlsh: cannot read history file: $!\n";
  }

  my $trie = new Tree::Trie;

  my @tag_names = $tagr->get_tag_names();

  $trie->add(@tag_names);

  $attribs->{completion_function} = sub {
    my ($text, $line, $start) = @_;
    return map {s/$text/$text/i; $_} $trie->lookup(lc $text);
  };

  for my $file (@ARGV) {
    my $file_fullpath = _test_and_canon($file);
    if ($file_fullpath) {
      if ($options{recurse}) {
        _dir_recurse($file_fullpath, sub {
                       my $filepath = shift;
                       shell_tag($filepath, @_);
                     }, $term, $trie);
      } else {
        shell_tag($file_fullpath, $term, $trie);
      }
    }
  }
  $tagr->db()->txn_commit();
  exit_and_commit(0);
}

if (defined $options{get_description}) {
  if (!@ARGV) {
    usage(2, "error: one or more filename arguments needed\n");
  }

  for my $filename (@ARGV) {
    my $file_fullpath = _test_and_canon($filename);
    if ($file_fullpath) {
      my $description = $tagr->get_description_of_file($file_fullpath);

      if (defined $description) {
        if ($verbose) {
          print "$filename: ", $description->detail(), "\n";
        } else {
          print $description->detail(), "\n";
        }
      } else {
        if ($verbose) {
          warn "no description found for: $file_fullpath\n";
        }
      }
    }
  }
}

if (defined $options{get_tags}) {
  if (!@ARGV) {
    usage(2, "error: one or more filename arguments needed\n");
  }

  for my $filename (@ARGV) {
    my $file_fullpath = _test_and_canon($filename);
    if ($file_fullpath) {
      my @tags = $tagr->get_tags_of_file($file_fullpath);

      if ($options{mix}) {
        # to do - shuffle list
        @tags = @tags;
      }

      if (@tags) {
        my @tag_names = map {$_->detail()} @tags;

        if ($verbose) {
          print "$filename: @tag_names\n";
        } else {
          print "@tag_names\n";
        }

      } else {
        if ($verbose) {
          warn "no tags found for: $file_fullpath\n";
        }
      }
    }
  }

}

sub _test_and_canon
{
  my $file = shift;
  if (-l $file) {
    if ($verbose) {
      warn "ignoring symbolic link: $file\n";
    }
    return undef;
  }

  if (!-r $file) {
    if ($verbose) {
      warn "ignoring unreadable file: $file\n";
    }
    return undef;
  }

  my $file_fullpath = abs_path($file);

  return $file_fullpath;
}

# if ($options{auto_tag}) {
#   if (@ARGV < 1) {
#     usage(2, "error: one or more files arguments needed\n");
#   }

#   for my $file (@ARGV) {
#     if (-e $file) {
#       _auto_tag_file($file);
#     } else {
#       warn "$0: warning: $file doesn't exists\n";
#     }
#   }
#   exit(0);
# }


